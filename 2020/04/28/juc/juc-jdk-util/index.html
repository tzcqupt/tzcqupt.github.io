<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入浅出多线程学习笔记-JDK工具"><meta name="keywords" content="Java,多线程"><meta name="author" content="tzcqupt"><meta name="copyright" content="tzcqupt"><title>深入浅出多线程学习笔记-JDK工具 | 个人学习博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="个人学习博客" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池原理"><span class="toc-number">1.</span> <span class="toc-text">线程池原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">1.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法中相关参数"><span class="toc-number">1.1.1.</span> <span class="toc-text">构造方法中相关参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor的策略"><span class="toc-number">1.1.2.</span> <span class="toc-text">ThreadPoolExecutor的策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池的状态"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">线程池的状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池主要的任务处理流程"><span class="toc-number">1.1.3.</span> <span class="toc-text">线程池主要的任务处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二次检查线程池的状态ctl-get"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">二次检查线程池的状态ctl.get()?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理流程"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">处理流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor如何做到线程复用的"><span class="toc-number">1.1.4.</span> <span class="toc-text">ThreadPoolExecutor如何做到线程复用的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-种常见的线程池"><span class="toc-number">1.2.</span> <span class="toc-text">4 种常见的线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-number">1.2.1.</span> <span class="toc-text">newCachedThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#运行流程"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">运行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用场景"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">1.2.2.</span> <span class="toc-text">newFixedThreadPool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#说明"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与CachedThreadPool的区别"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">与CachedThreadPool的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-number">1.2.3.</span> <span class="toc-text">newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newScheduledThreadPool"><span class="toc-number">1.2.4.</span> <span class="toc-text">newScheduledThreadPool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#阻塞队列"><span class="toc-number">2.</span> <span class="toc-text">阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞队列的由来"><span class="toc-number">2.1.</span> <span class="toc-text">阻塞队列的由来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">2.2.</span> <span class="toc-text">BlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue的操作方法"><span class="toc-number">2.2.1.</span> <span class="toc-text">BlockingQueue的操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue的实现类"><span class="toc-number">2.2.2.</span> <span class="toc-text">BlockingQueue的实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DelayQueue"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">DelayQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PriorityBlockingQueue"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">SynchronousQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞队列的原理"><span class="toc-number">2.3.</span> <span class="toc-text">阻塞队列的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造器"><span class="toc-number">2.3.1.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put操作"><span class="toc-number">2.3.2.</span> <span class="toc-text">put操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put流程总结"><span class="toc-number">2.3.3.</span> <span class="toc-text">put流程总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#take操作"><span class="toc-number">2.3.4.</span> <span class="toc-text">take操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#take流程总结"><span class="toc-number">2.3.5.</span> <span class="toc-text">take流程总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项"><span class="toc-number">2.3.6.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例和使用场景"><span class="toc-number">2.4.</span> <span class="toc-text">示例和使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者-消费者模型"><span class="toc-number">2.4.1.</span> <span class="toc-text">生产者-消费者模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#锁接口和类"><span class="toc-number">3.</span> <span class="toc-text">锁接口和类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized的缺点"><span class="toc-number">3.1.</span> <span class="toc-text">synchronized的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁的分类"><span class="toc-number">3.2.</span> <span class="toc-text">锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可重入锁和非可重入锁"><span class="toc-number">3.2.1.</span> <span class="toc-text">可重入锁和非可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公平锁与非公平锁"><span class="toc-number">3.2.2.</span> <span class="toc-text">公平锁与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读写锁和排它锁"><span class="toc-number">3.2.3.</span> <span class="toc-text">读写锁和排它锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-中接口和类"><span class="toc-number">3.3.</span> <span class="toc-text">JDK 中接口和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类AQS-AQLS-AOS"><span class="toc-number">3.3.1.</span> <span class="toc-text">抽象类AQS&#x2F;AQLS&#x2F;AOS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口Condition-Lock-ReadWriteLock"><span class="toc-number">3.3.2.</span> <span class="toc-text">接口Condition&#x2F;Lock&#x2F;ReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">3.3.3.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">3.3.4.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StampedLock"><span class="toc-number">3.3.5.</span> <span class="toc-text">StampedLock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并发集合容器"><span class="toc-number">4.</span> <span class="toc-text">并发集合容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#并发容器"><span class="toc-number">4.1.</span> <span class="toc-text">并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#并发Map"><span class="toc-number">4.1.1.</span> <span class="toc-text">并发Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap类"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">ConcurrentHashMap类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentMap接口"><span class="toc-number">4.1.1.1.1.</span> <span class="toc-text">ConcurrentMap接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentHashMap原理"><span class="toc-number">4.1.1.1.2.</span> <span class="toc-text">ConcurrentHashMap原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentSkipListMap类"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">ConcurrentSkipListMap类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentNavigableMap接口"><span class="toc-number">4.1.1.2.1.</span> <span class="toc-text">ConcurrentNavigableMap接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentSkipListMap原理"><span class="toc-number">4.1.1.2.2.</span> <span class="toc-text">ConcurrentSkipListMap原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发Queue"><span class="toc-number">4.1.2.</span> <span class="toc-text">并发Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发Set"><span class="toc-number">4.1.3.</span> <span class="toc-text">并发Set</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CopyOnWrite"><span class="toc-number">5.</span> <span class="toc-text">CopyOnWrite</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">5.2.</span> <span class="toc-text">CopyOnWriteArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点"><span class="toc-number">5.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点"><span class="toc-number">5.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程通信工具类"><span class="toc-number">6.</span> <span class="toc-text">线程通信工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-number">6.1.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-number">6.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例"><span class="toc-number">6.1.2.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">6.1.3.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exchanger"><span class="toc-number">6.2.</span> <span class="toc-text">Exchanger</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#案例-1"><span class="toc-number">6.2.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">6.3.</span> <span class="toc-text">CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#案例-2"><span class="toc-number">6.3.1.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-1"><span class="toc-number">6.3.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">6.4.</span> <span class="toc-text">CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#案例-3"><span class="toc-number">6.4.1.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-2"><span class="toc-number">6.4.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Phaser"><span class="toc-number">6.5.</span> <span class="toc-text">Phaser</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量解释"><span class="toc-number">6.5.1.</span> <span class="toc-text">变量解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例-4"><span class="toc-number">6.5.2.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-3"><span class="toc-number">6.5.3.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fork-Join框架"><span class="toc-number">7.</span> <span class="toc-text">Fork&#x2F;Join框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念-1"><span class="toc-number">7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作窃取算法"><span class="toc-number">7.2.</span> <span class="toc-text">工作窃取算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-Join的具体实现"><span class="toc-number">7.3.</span> <span class="toc-text">Fork&#x2F;Join的具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinTask"><span class="toc-number">7.3.1.</span> <span class="toc-text">ForkJoinTask</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-方法"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">fork()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join-方法"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">join()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool"><span class="toc-number">7.3.2.</span> <span class="toc-text">ForkJoinPool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#源码"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">源码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://portrait.gitee.com/uploads/avatars/user/762/2287861_tzcqupt_1588209320.png"></div><div class="author-info__name text-center">tzcqupt</div><div class="author-info__description text-center">一个努力的Java程序员小白</div><div class="follow-button"><a href="https://gitee.com/tzcqupt" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">27</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">19</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">个人学习博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">深入浅出多线程学习笔记-JDK工具</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D/">编程书籍</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">10.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 38 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p>Java中的线程池顶层接口是<code>Executor</code>接口，<code>ThreadPoolExecutor</code>是这个接口的实现类。</p>
<p>线程池中有两类线程：核心线程和非核心线程。</p>
<p>核心线程一直存在，闲置不会被销毁。非核心线程长时间闲置会被销毁。</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><code>ThreadPoolExecutor</code></h2><h3 id="构造方法中相关参数"><a href="#构造方法中相关参数" class="headerlink" title="构造方法中相关参数"></a>构造方法中相关参数</h3><ul>
<li><p><strong>int corePoolSize</strong>：该线程池中<strong>核心线程数最大值</strong>.</p>
</li>
<li><p><strong>int maximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong> 。</p>
</li>
<li><p><strong>long keepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong>。</p>
</li>
<li><p><strong>TimeUnit unit</strong>：keepAliveTime的单位。枚举类，包括<code>NANOSECONDS</code>,<code>MICROSECONDS</code> 、<code>MILLISECONDS</code> 、<code>SECONDS</code> 、<code>MINUTES</code> 、<code>MINUTES</code> 、<code>DAYS</code>。</p>
</li>
<li><p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>。</p>
<ul>
<li><p><strong>LinkedBlockingQueue</strong></p>
<p>链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</p>
</li>
<li><p><strong>ArrayBlockingQueue</strong></p>
<p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p>
</li>
<li><p><strong>SynchronousQueue</strong></p>
<p>同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</p>
</li>
<li><p><strong>DelayQueue</strong></p>
<p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</p>
</li>
</ul>
</li>
<li><p><strong>ThreadFactory threadFactory</strong>创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p>
</li>
<li><p><strong>RejectedExecutionHandler handler</strong> <strong>拒绝处理策略</strong>，线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</p>
<ul>
<li><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常。</li>
<li><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</li>
<li><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</li>
<li><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</li>
</ul>
</li>
</ul>
<h3 id="ThreadPoolExecutor的策略"><a href="#ThreadPoolExecutor的策略" class="headerlink" title="ThreadPoolExecutor的策略"></a>ThreadPoolExecutor的策略</h3><p>线程池本身有一个调度线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。</p>
<h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><p><code>ThreadPoolExecutor</code>类中定义了一个<code>volatile int</code>变量<strong>runState</strong>来表示线程池的状态 ，分别为RUNNING、SHUTDOWN、STOP、TIDYING 、TERMINATED。</p>
<ul>
<li><p>线程池创建后处于<strong>RUNNING</strong>状态。</p>
</li>
<li><p>调用<code>shutdown()</code>方法后处于<strong>SHUTDOWN</strong>状态，线程池不能接受新的任务，清除一些空闲worker,会等待阻塞队列的任务完成。</p>
</li>
<li><p>调用<code>shutdownNow()</code>方法后处于<strong>STOP</strong>状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，poolsize=0,阻塞队列的size也为0。</p>
</li>
<li><p>当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为<strong>TIDYING</strong>状态。接着会执行<code>terminated()</code>函数。</p>
<blockquote>
<p><code>ThreadPoolExecutor</code>中有一个控制状态的属性叫<code>ctl</code>，它是一个<code>AtomicInteger</code>类型的变量。</p>
</blockquote>
</li>
<li><p>线程池处在TIDYING状态时，<strong>执行完<code>terminated()</code>方法之后</strong>，就会由 <strong>TIDYING -&gt; TERMINATED</strong>， 线程池被设置为TERMINATED状态。</p>
</li>
</ul>
<h3 id="线程池主要的任务处理流程"><a href="#线程池主要的任务处理流程" class="headerlink" title="线程池主要的任务处理流程"></a>线程池主要的任务处理流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.8 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果不小于corePoolSize，则将任务添加到workQueue队列。</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 2.2 线程池处于running状态，但是没有线程，则创建线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.如果放入workQueue失败，则创建非核心线程执行任务，</span></span><br><span class="line">    <span class="comment">// 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二次检查线程池的状态ctl-get"><a href="#二次检查线程池的状态ctl-get" class="headerlink" title="二次检查线程池的状态ctl.get()?"></a>二次检查线程池的状态<code>ctl.get()</code>?</h4><p>在多线程的环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程池状态就改变了。判断是否将<code>command</code>加入<code>workqueue</code>是线程池之前的状态。倘若没有二次检查，万一线程池处于非<strong>RUNNING</strong>状态（在多线程环境下很有可能发生），那么<code>command</code>永远不会执行。</p>
<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><ol>
<li><p>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></p>
</li>
<li><p>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。 </p>
</li>
<li><p>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></p>
</li>
<li><p>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</p>
</li>
</ol>
<p><img src="https://gitee.com/tzcqupt/blog-image/raw/master/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.PNG" alt=""></p>
<h3 id="ThreadPoolExecutor如何做到线程复用的"><a href="#ThreadPoolExecutor如何做到线程复用的" class="headerlink" title="ThreadPoolExecutor如何做到线程复用的"></a>ThreadPoolExecutor如何做到线程复用的</h3><p>//todo 后面再阅读</p>
<p><a href="https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/12#12-2-4-threadpoolexecutor-ru-he-zuo-dao-xian-cheng-fu-yong-de" target="_blank" rel="noopener">https://redspider.gitbook.io/concurrent/di-san-pian-jdk-gong-ju-pian/12#12-2-4-threadpoolexecutor-ru-he-zuo-dao-xian-cheng-fu-yong-de</a></p>
<h2 id="4-种常见的线程池"><a href="#4-种常见的线程池" class="headerlink" title="4 种常见的线程池"></a>4 种常见的线程池</h2><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><ol>
<li><p>提交任务进线程池。</p>
</li>
<li><p>因为<strong>corePoolSize</strong>为0的关系，不创建核心线程，线程池最大为Integer.MAX_VALUE。</p>
</li>
<li><p>尝试将任务添加到<strong>SynchronousQueue</strong>队列。</p>
</li>
<li><p>如果SynchronousQueue入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从SynchronousQueue拉取任务并在当前线程执行。</p>
</li>
<li><p>如果SynchronousQueue已有任务在等待，入列操作将会阻塞。</p>
</li>
</ol>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当需要执行很多<strong>短时间</strong>的任务时，CacheThreadPool的线程复用率比较高， 会显著的<strong>提高性能</strong>。而且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool并不会占用很多资源。</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>核心线程数量和总线程数量相等，都是传入的参数nThreads，所以只能创建核心线程，不能创建非核心线程。因为LinkedBlockingQueue的默认大小是Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。</p>
<h4 id="与CachedThreadPool的区别"><a href="#与CachedThreadPool的区别" class="headerlink" title="与CachedThreadPool的区别"></a>与CachedThreadPool的区别</h4><ul>
<li><p>因为 corePoolSize == maximumPoolSize ，所以FixedThreadPool只会创建核心线程。 而CachedThreadPool因为corePoolSize=0，所以只会创建非核心线程。</p>
</li>
<li><p>在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回。</p>
</li>
<li><p>由于线程不会被回收，会一直卡在阻塞，所以<strong>没有任务的情况下， FixedThreadPool占用资源更多</strong>。 </p>
</li>
<li><p>都几乎不会触发拒绝策略，但是原理不同。FixedThreadPool是因为阻塞队列可以很大（最大为Integer最大值），故几乎不会触发拒绝策略；CachedThreadPool是因为线程池很大（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</p>
</li>
</ul>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有且仅有一个核心线程（ corePoolSize == maximumPoolSize=1），使用了LinkedBlockingQueue（容量很大），所以，<strong>不会创建非核心线程</strong>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。</p>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个定长线程池，支持定时及周期性任务执行。</p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><h2 id="阻塞队列的由来"><a href="#阻塞队列的由来" class="headerlink" title="阻塞队列的由来"></a>阻塞队列的由来</h2><p>生产者-消费者模式：生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费。</p>
<p>实现该模式，需要让<strong>多个线程操作共享变量</strong>（即资源），所以很容易引发<strong>线程安全问题</strong>，造成<strong>重复消费</strong>和<strong>死锁</strong>，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个<strong>等待-唤醒</strong>逻辑都需要自己实现。</p>
<p>JDK中实现该逻辑的数据结构<code>BlockingQueue</code>,只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>BlockingQueue是Java util.concurrent包下重要的数据结构，区别于普通的队列，BlockingQueue提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。BlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<strong>BlockingQueue就是存放元素的容器</strong>。</p>
<h3 id="BlockingQueue的操作方法"><a href="#BlockingQueue的操作方法" class="headerlink" title="BlockingQueue的操作方法"></a>BlockingQueue的操作方法</h3><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td><strong>put(e)</strong></td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td><strong>take()</strong></td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</p>
</li>
<li><p>返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是true / false。</p>
</li>
<li><p>一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</p>
</li>
<li><p>超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。</p>
</li>
</ul>
<blockquote>
<p>不能往阻塞队列中插入null,会抛出空指针异常。</p>
<p>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</p>
</blockquote>
<h3 id="BlockingQueue的实现类"><a href="#BlockingQueue的实现类" class="headerlink" title="BlockingQueue的实现类"></a>BlockingQueue的实现类</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>由<strong>数组</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是数组，故具有数组的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line">    <span class="comment">//..省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是<strong>非公平锁</strong>。</p>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>由<strong>链表</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p>
<h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。 </p>
<p>DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 </p>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是公平锁。</p>
<blockquote>
<p><strong>PriorityBlockingQueue</strong>不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</strong>对于使用默认大小的<strong>LinkedBlockingQueue</strong>也是一样的。</p>
</blockquote>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>这个队列比较特殊，<strong>没有任何内部容量</strong>，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然</p>
<h2 id="阻塞队列的原理"><a href="#阻塞队列的原理" class="headerlink" title="阻塞队列的原理"></a>阻塞队列的原理</h2><p>利用了Lock锁的多条件（Condition）阻塞控制。</p>
<p>ArrayBlockingQueue JDK 1.8的源码。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>除了初始化队列的大小和是否是公平锁之外，还对同一个锁（lock）初始化了两个监视器，分别是notEmpty和notFull。这两个监视器的作用目前可以简单理解为标记分组，当该线程是put操作时，给他加上监视器notFull,标记这个线程是一个生产者；当线程是take操作时，给他加上监视器notEmpty，标记这个线程是消费者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">//下一个待取出元素索引</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">//下一个待添加元素索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//内部锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">//消费者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">//生产者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..省略其他代码</span></span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 1.自旋拿锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.判断队列是否满了</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span></span><br><span class="line">            <span class="comment">// 等待notFull的唤醒，唤醒之后继续执行while循环。</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">// 3.如果没有满，则进入队列</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 4 唤醒一个等待的线程</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put流程总结"><a href="#put流程总结" class="headerlink" title="put流程总结"></a>put流程总结</h3><ol>
<li><p>所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</p>
</li>
<li><p>判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。</p>
</li>
<li><p>如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</p>
</li>
<li><p>唤醒一个标记为notEmpty（消费者）的线程。</p>
</li>
</ol>
<h3 id="take操作"><a href="#take操作" class="headerlink" title="take操作"></a>take操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="take流程总结"><a href="#take流程总结" class="headerlink" title="take流程总结"></a>take流程总结</h3><ol>
<li><p>所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</p>
</li>
<li><p>判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。</p>
</li>
<li><p>如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</p>
</li>
<li><p>唤醒一个标记为notFull（生产者）的线程。</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>put和take操作都需要<strong>先获取锁</strong>，没有获取到锁的线程会被挡在第一道大门之外自旋拿锁，直到获取到锁。</p>
</li>
<li><p>就算拿到锁了之后，也<strong>不一定</strong>会顺利进行put/take操作，需要判断<strong>队列是否可用</strong>（是否满/空），如果不可用，则会被阻塞，<strong>并释放锁</strong>。</p>
</li>
<li><p>在第2点被阻塞的线程会被唤醒，但是在唤醒之后，<strong>依然需要拿到锁</strong>才能继续往下执行，否则，自旋拿锁，拿到锁了再while判断队列是否可用（这也是为什么不用if判断，而使用while判断的原因）。</p>
</li>
</ol>
<h2 id="示例和使用场景"><a href="#示例和使用场景" class="headerlink" title="示例和使用场景"></a>示例和使用场景</h2><h3 id="生产者-消费者模型"><a href="#生产者-消费者模型" class="headerlink" title="生产者-消费者模型"></a>生产者-消费者模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tz.juc.block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用阻塞队列实现的生产者和消费者模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tzcqupt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueueProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueSize = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        BlockQueueProducerConsumer blockQueueProducerConsumer = <span class="keyword">new</span> BlockQueueProducerConsumer();</span><br><span class="line">        Producer producer = blockQueueProducerConsumer.<span class="keyword">new</span> Producer();</span><br><span class="line">        Consumer consumer = blockQueueProducerConsumer.<span class="keyword">new</span> Consumer();</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            consume();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    System.out.println(<span class="string">"从队列取走一个元素，队列剩余"</span>+queue.size()+<span class="string">"个元素"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            produce();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"向队列取中插入一个元素，队列剩余空间："</span>+(queueSize-queue.size()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="锁接口和类"><a href="#锁接口和类" class="headerlink" title="锁接口和类"></a>锁接口和类</h1><h2 id="synchronized的缺点"><a href="#synchronized的缺点" class="headerlink" title="synchronized的缺点"></a>synchronized的缺点</h2><ul>
<li><p>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，<strong>同一时间只能有一个线程执行</strong>。</p>
</li>
<li><p>synchronized无法知道线程有没有成功获取到锁</p>
</li>
<li><p>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</p>
</li>
</ul>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="可重入锁和非可重入锁"><a href="#可重入锁和非可重入锁" class="headerlink" title="可重入锁和非可重入锁"></a>可重入锁和非可重入锁</h3><p>重入锁，就是支持重新进入的锁，也就是说这个锁支持一个<strong>线程对资源重复加锁</strong>。</p>
<p>synchronized关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。</p>
<p>如果我们自己在继承AQS实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。</p>
<p><code>ReentrantLock</code>的中文意思就是可重入锁。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平==&gt;先来后到，FIFO</p>
<p>如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。</p>
<p>一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</strong>。</p>
<p><code>ReentrantLock</code>支持非公平锁和公平锁两种。</p>
<h3 id="读写锁和排它锁"><a href="#读写锁和排它锁" class="headerlink" title="读写锁和排它锁"></a>读写锁和排它锁</h3><p><strong>排它锁</strong>：同一时刻只允许一个线程进行访问。<code>synchronized</code>用的锁和<code>ReentrantLock</code>都是排它锁。</p>
<p><strong>读写锁</strong>可以再同一时刻允许多个读线程访问。Java提供了<code>ReentrantReadWriteLock</code>类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p>
<blockquote>
<p>注意，即使用读写锁，在写线程访问时，所有的读线程和其它写线程均被阻塞。</p>
</blockquote>
<h2 id="JDK-中接口和类"><a href="#JDK-中接口和类" class="headerlink" title="JDK 中接口和类"></a>JDK 中接口和类</h2><h3 id="抽象类AQS-AQLS-AOS"><a href="#抽象类AQS-AQLS-AOS" class="headerlink" title="抽象类AQS/AQLS/AOS"></a>抽象类AQS/AQLS/AOS</h3><p><strong>AQS</strong>（AbstractQueuedSynchronizer）是在JDK 1.5 发布的，提供了一个“队列同步器”的基本功能实现。而AQS里面的“资源”是用一个<code>int</code>类型的数据来表示的，有时候我们的业务需求资源的数量超出了<code>int</code>的范围，所以在JDK 1.6 中，多了一个<strong>AQLS</strong>（AbstractQueuedLongSynchronizer）。它的代码跟AQS几乎一样，只是把资源的类型变成了<code>long</code>类型。</p>
<p>AQS和AQLS都继承了一个类叫<strong>AOS</strong>（AbstractOwnableSynchronizer）。这个类也是在JDK 1.6 中出现的。这个类只有几行简单的代码。它是用于表示锁与持有者之间的关系（独占模式）。</p>
<h3 id="接口Condition-Lock-ReadWriteLock"><a href="#接口Condition-Lock-ReadWriteLock" class="headerlink" title="接口Condition/Lock/ReadWriteLock"></a>接口Condition/Lock/ReadWriteLock</h3><p>juc.locks包下共有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。其中，Lock和ReadWriteLock从名字就可以看得出来，分别是锁和读写锁的意思。Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock接口中有一个方法是可以获得一个<code>Condition</code>。</p>
<p>每个对象都可以用继承自<code>Object</code>的<strong>wait/notify</strong>方法来实现<strong>等待/通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待/通知模式。</p>
<p>Condition和Object的wait/notify基本相似。其中，Condition的await方法对应的是Object的wait方法，而Condition的<strong>signal/signalAll</strong>方法则对应Object的notify/notifyAll()。</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code>是一个非抽象类，它是<code>Lock</code>接口的JDK默认实现，实现了锁的基本功能。从名字上看，它是一个<strong>可重入锁</strong>，从源码上看，它内部有一个抽象类<code>Sync</code>，是继承了<code>AQS</code>，自己实现的一个同步器。同时，<code>ReentrantLock</code>内部有两个非抽象类<code>NonfairSync</code>和<code>FairSync</code>，它们都继承了<code>Sync</code>。从名字上看得出，分别是<strong>非公平同步器</strong>和<strong>公平同步器</strong>的意思。这意味着<code>ReentrantLock</code>可以支持<strong>公平锁</strong>和<strong>非公平锁</strong></p>
<p>通过看着两个同步器的源码可以发现，它们的实现都是<strong>独占</strong>的。都调用了AOS的<code>setExclusiveOwnerThread</code>方法，所以<code>ReentrantLock</code>的锁的”独占“的，也就是说，它的锁都是<strong>排他锁</strong>，不能共享。</p>
<p>在<code>ReentrantLock</code>的构造方法里，可以传入一个<code>boolean</code>类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过<code>isFair()</code>方法来查看。</p>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>它是R<code>eadWriteLock</code>接口的JDK默认实现。它与<code>ReentrantLock</code>的功能类似，同样是<strong>可重入</strong>的，支持<strong>非公平锁</strong>和<strong>公平锁</strong>。不同的是，它还支持<strong>读写锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法，初始化两个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁和写锁的方法</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantReadWriteLock实现了读写锁，但它有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。我们称这种现象为“写饥饿”。</p>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>来自Java 8  它没有实现<code>Lock</code>接口和<code>ReadWriteLoc</code>k接口，但它其实是实现了“读写锁”的功能，并且性能比<code>ReentrantReadWriteLock</code>更高。<code>StampedLock</code>还把读锁分为了<strong>乐观读锁</strong>和<strong>悲观读锁</strong>两种。</p>
<p>官方代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 写锁的使用</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> stamp = sl.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       x += deltaX;</span><br><span class="line">       y += deltaY;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       sl.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 乐观读锁的使用</span></span><br><span class="line">   <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">// 获取乐观读锁</span></span><br><span class="line">     <span class="keyword">double</span> currentX = x, currentY = y;</span><br><span class="line">     <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">// //检查乐观读锁后是否有其他写锁发生，有则返回false</span></span><br><span class="line">        stamp = sl.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          currentX = x;</span><br><span class="line">          currentY = y;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           sl.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 悲观读锁以及读锁升级写锁的使用</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> stamp = sl.readLock(); <span class="comment">// 悲观读锁</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">         <span class="comment">// 读锁尝试转换为写锁：转换成功后相当于获取了写锁，转换失败相当于有写锁被占用</span></span><br><span class="line">         <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); </span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">// 如果转换成功</span></span><br><span class="line">           stamp = ws; <span class="comment">// 读锁的票据更新为写锁的</span></span><br><span class="line">           x = newX;</span><br><span class="line">           y = newY;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123; <span class="comment">// 如果转换失败</span></span><br><span class="line">           sl.unlockRead(stamp); <span class="comment">// 释放读锁</span></span><br><span class="line">           stamp = sl.writeLock(); <span class="comment">// 强制获取写锁</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       sl.unlock(stamp); <span class="comment">// 释放所有锁</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并发集合容器"><a href="#并发集合容器" class="headerlink" title="并发集合容器"></a>并发集合容器</h1><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>常用容器类架构</p>
<p><img src="https://gitee.com/tzcqupt/blog-image/raw/master/img/%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E7%B1%BB.png" alt=""></p>
<h3 id="并发Map"><a href="#并发Map" class="headerlink" title="并发Map"></a>并发Map</h3><h4 id="ConcurrentHashMap类"><a href="#ConcurrentHashMap类" class="headerlink" title="ConcurrentHashMap类"></a><code>ConcurrentHashMap</code>类</h4><h5 id="ConcurrentMap接口"><a href="#ConcurrentMap接口" class="headerlink" title="ConcurrentMap接口"></a>ConcurrentMap接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    <span class="comment">//如果插入的key相同，则不替换原有的value值；</span></span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除元素</span></span><br><span class="line">    <span class="comment">//增加了对value的判断，如果要删除的key-value不能与Map中原有的key-value对应上，则不会删除该元素;</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换元素</span></span><br><span class="line">    <span class="comment">//增加了对value值的判断，如果key-oldValue能与Map中原有的key-value对应上，才进行替换操作；</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换元素</span></span><br><span class="line">    <span class="comment">//如果key存在则直接替换</span></span><br><span class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a><code>ConcurrentHashMap</code>原理</h5><p><code>ConcurrentHashMap</code>提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫分段锁(Lock Striping)。</p>
<p>就是<strong>将数据分段，对每一段数据分配一把锁</strong>。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p><code>ConcurrentHashMap</code>是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，HashEntry则用于存储键值对数据。</p>
<p>一个<code>ConcurrentHashMap</code>里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构（同HashMap一样，它也会在长度达到8的时候转化为红黑树）的元素， 每个Segment守护者一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<h4 id="ConcurrentSkipListMap类"><a href="#ConcurrentSkipListMap类" class="headerlink" title="ConcurrentSkipListMap类"></a><code>ConcurrentSkipListMap</code>类</h4><h5 id="ConcurrentNavigableMap接口"><a href="#ConcurrentNavigableMap接口" class="headerlink" title="ConcurrentNavigableMap接口"></a>ConcurrentNavigableMap接口</h5><p><code>ConcurrentNavigableMap</code>接口继承了<code>NavigableMap</code>接口，这个接口提供了针对给定搜索目标返回最接近匹配项的导航方法。</p>
<h5 id="ConcurrentSkipListMap原理"><a href="#ConcurrentSkipListMap原理" class="headerlink" title="ConcurrentSkipListMap原理"></a><code>ConcurrentSkipListMap</code>原理</h5><p><code>ConcurrentNavigableMap</code>接口的主要实现类是<code>ConcurrentSkipListMap</code>类。从名字上来看，它的底层使用的是跳表（SkipList）的数据结构。跳表是一种<strong>空间换时间</strong>的数据结构，可以使用CAS来保证并发安全性。</p>
<h3 id="并发Queue"><a href="#并发Queue" class="headerlink" title="并发Queue"></a>并发Queue</h3><p>JDK提供了对队列和双端队列的线程安全的类：<code>ConcurrentLinkedDeque</code>和<code>ConcurrentLinkedQueue</code>。这两个类是使用CAS来实现线程安全的。</p>
<h3 id="并发Set"><a href="#并发Set" class="headerlink" title="并发Set"></a>并发Set</h3><p>JDK提供了<code>ConcurrentSkipListSet</code>，是线程安全的有序的集合。底层是使用<code>ConcurrentSkipListMap</code>实现。</p>
<p>google的guava框架的线程安全set <code>Set&lt;String&gt; s = Sets.newConcurrentHashSet();</code></p>
<h1 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CopyOnWrite是计算机设计领域中的一种优化策略，也是一种在并发场景下常用的设计思想——写入时复制思想。</p>
<p>就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，这个时候系统将会复制一个当前数据源的副本给调用者修改。</p>
<p>CopyOnWrite容器即<strong>写时复制的容器</strong>,当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p>
<p>可以在并发的场景下对容器进行”读操作”而不需要”加锁”，从而达到读写分离的目的。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>CopyOnWriteArrayList经常被用于“读多写少”的并发场景，是因为CopyOnWriteArrayList无需任何同步措施，大大增强了读的性能。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>CopyOnWriteArrayList每次执行写操作都会将原容器进行拷贝了一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁Full GC（ZGC因为没有使用Full GC）</li>
<li>opyOnWriteArrayList由于实现的原因，写和读分别作用在不同新老容器上，在写操作执行过程中，读不会阻塞，但读取到的却是老容器的数据。</li>
</ol>
<blockquote>
<p>如果我们希望写入的数据马上能准确地读取，请不要使用CopyOnWrite容器。</p>
</blockquote>
<h1 id="线程通信工具类"><a href="#线程通信工具类" class="headerlink" title="线程通信工具类"></a>线程通信工具类</h1><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>作用：限制线程的数量。</p>
<p>提供的功能就是多个线程彼此“打信号”。而这个“信号”是一个<code>int</code>类型的数据，也可以看成是一种“资源”。</p>
<p>可以在构造函数中传入初始资源总数，以及是否使用“公平”的同步器。默认情况下，是非公平的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认情况下使用非公平</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最主要的方法是acquire方法和release方法。acquire()方法会申请一个permit，而release方法会释放一个permit。当然，你也可以申请多个acquire(int permits)或者释放多个release(int permits)。</p>
<p>每次acquire，permits就会减少一个或者多个。如果减少到了0，再有其他线程来acquire，那就要阻塞这个线程直到有其它线程release permit为止。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>Semaphore往往用于资源有限的场景中，去限制线程的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> value, Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire(); <span class="comment">// 获取permit</span></span><br><span class="line">                System.out.println(String.format(<span class="string">"当前线程是%d, 还剩%d个资源，还有%d个线程在等待"</span>,</span><br><span class="line">                        value, semaphore.availablePermits(), semaphore.getQueueLength()));</span><br><span class="line">                <span class="comment">// 睡眠随机时间，打乱释放顺序</span></span><br><span class="line">                Random random =<span class="keyword">new</span> Random();</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                semaphore.release(); <span class="comment">// 释放permit</span></span><br><span class="line">                System.out.println(String.format(<span class="string">"线程%d释放了资源"</span>, value));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i, semaphore)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Semaphore内部有一个继承了AQS的同步器Sync，重写了<code>tryAcquireShared</code>方法。在这个方法里，会去尝试获取资源。</p>
<p>如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。然后当前线程就会进入AQS的等待队列。</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger类用于两个线程交换数据。它支持泛型，也就是说你可以在两个线程之间传送任何数据。</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"这是线程A，得到了另一个线程的数据："</span></span><br><span class="line">                        + exchanger.exchange(<span class="string">"这是来自线程A的数据"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"这个时候线程A是阻塞的，在等待线程B的数据"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"这是线程B，得到了另一个线程的数据："</span></span><br><span class="line">                        + exchanger.exchange(<span class="string">"这是来自线程B的数据"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出：</strong></p>
<blockquote>
<p>这个时候线程A是阻塞的，在等待线程B的数据 </p>
<p>这是线程B，得到了另一个线程的数据：这是来自线程A的数据 </p>
<p>这是线程A，得到了另一个线程的数据：这是来自线程B的数据</p>
</blockquote>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>线程等待直到计数器减为0时开始工作。CountDown代表计数递减，Latch表示屏障。</p>
<p>假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。</p>
<h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><p>玩游戏的时候，在游戏真正开始之前，一般会等待一些前置任务完成，比如“加载地图数据”，“加载人物模型”，“加载背景音乐”等等。只有当所有的东西都加载完成后，玩家才能真正进入游戏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义前置任务线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PreTaskThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String task;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PreTaskThread</span><span class="params">(String task, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                System.out.println(task + <span class="string">" - 任务完成"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 假设有三个模块需要加载</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主任务</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"等待数据加载..."</span>);</span><br><span class="line">                System.out.println(String.format(<span class="string">"还有%d个前置任务"</span>, countDownLatch.getCount()));</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(<span class="string">"数据加载完成，正式开始游戏！"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前置任务</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载地图数据"</span>, countDownLatch)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载人物模型"</span>, countDownLatch)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载背景音乐"</span>, countDownLatch)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>内部定义了一个AQS的实现类Sync。</p>
<blockquote>
<p>构造器中的<strong>计数值（count）实际上就是闭锁需要等待的线程数量</strong>。这个值只能被设置一次，而且CountDownLatch<strong>没有提供任何机制去重新设置这个计数值</strong>。</p>
</blockquote>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>理解：循环的屏障，作用跟CountDownLatch类似，但是可以重复使用。</p>
<h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><p>如果玩一个游戏有多个“关卡”，那使用CountDownLatch显然不太合适，那需要为每个关卡都创建一个实例。那我们可以使用CyclicBarrier来实现每个关卡的数据加载等待功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PreTaskThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String task;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PreTaskThread</span><span class="params">(String task, CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 假设总共三个关卡</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    System.out.println(String.format(<span class="string">"关卡%d的任务%s完成"</span>, i, task));</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                cyclicBarrier.reset(); <span class="comment">// 重置屏障</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"本关卡所有前置任务完成，开始游戏..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载地图数据"</span>, cyclicBarrier)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载人物模型"</span>, cyclicBarrier)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载背景音乐"</span>, cyclicBarrier)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出：</p>
<blockquote>
<p>关卡1的任务加载人物模型完成<br>关卡1的任务加载背景音乐完成<br>关卡1的任务加载地图数据完成<br>本关卡所有前置任务完成，开始游戏…<br>关卡2的任务加载人物模型完成<br>关卡2的任务加载背景音乐完成<br>关卡2的任务加载地图数据完成<br>本关卡所有前置任务完成，开始游戏…<br>关卡3的任务加载背景音乐完成<br>关卡3的任务加载人物模型完成<br>关卡3的任务加载地图数据完成<br>本关卡所有前置任务完成，开始游戏…</p>
</blockquote>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p><code>CyclicBarrier</code>没有分为<code>await()</code>和<code>countDown()</code>，而是只有单独的一个<code>await()</code>方法。</p>
<p>一旦调用await()方法的线程数量等于构造方法中传入的任务总量（这里是3），就代表达到屏障了。<code>CyclicBarrier</code>允许我们在达到屏障的时候可以执行一个任务，可以在构造方法传入一个<code>Runnable</code>类型的对象。上述案例就是在达到屏障时，输出“本关卡所有前置任务完成，开始游戏…”。</p>
<p><code>CyclicBarrier</code>内部使用的是Lock + Condition实现的等待/通知模式</p>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p>JDK 1.7出现，移相器，增强的<code>CyclicBarrier</code>.</p>
<p><code>CyclicBarrier</code>，可以发现它在构造方法里传入“任务总量”<code>parties</code>之后，就不能修改这个值了，并且每次调用<code>await()</code>方法也只能消耗一个<code>parties</code>计数。但Phaser可以动态地调整任务总量！</p>
<h3 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h3><ul>
<li><p>party：对应一个线程，数量可以通过register或者构造参数传入;</p>
</li>
<li><p>arrive：对应一个party的状态，初始时是unarrived，当调用<code>arriveAndAwaitAdvance()</code>或者 <code>arriveAndDeregister()</code>进入arrive状态，可以通过<code>getUnarrivedParties()</code>获取当前未到达的数量;</p>
</li>
<li><p>register：注册一个party，每一阶段必须所有注册的party都到达才能进入下一阶段;</p>
</li>
<li><p>deRegister：减少一个party。</p>
</li>
<li><p>phase：阶段，当所有注册的party都arrive之后，将会调用Phaser的<code>onAdvance()</code>方法来判断是否要进入下一阶段。</p>
</li>
</ul>
<h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><p>假设我们游戏有三个关卡，但只有第一个关卡有新手教程，需要加载新手教程模块。但后面的第二个关卡和第三个关卡都不需要。我们可以用Phaser来做这个需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PreTaskThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String task;</span><br><span class="line">        <span class="keyword">private</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PreTaskThread</span><span class="params">(String task, Phaser phaser)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 第二次关卡起不加载NPC，跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; <span class="string">"加载新手教程"</span>.equals(task)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    System.out.println(String.format(<span class="string">"关卡%d，需要加载%d个模块，当前模块【%s】"</span>,</span><br><span class="line">                            i, phaser.getRegisteredParties(), task));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从第二个关卡起，不加载NPC</span></span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; <span class="string">"加载新手教程"</span>.equals(task)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"下次关卡移除加载【新手教程】模块"</span>);</span><br><span class="line">                        phaser.arriveAndDeregister(); <span class="comment">// 移除一个模块</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        phaser.arriveAndAwaitAdvance();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">4</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"第%d次关卡准备完成"</span>, phase + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">return</span> phase == <span class="number">3</span> || registeredParties == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载地图数据"</span>, phaser)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载人物模型"</span>, phaser)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载背景音乐"</span>, phaser)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> PreTaskThread(<span class="string">"加载新手教程"</span>, phaser)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<blockquote>
<p>关卡1，需要加载4个模块，当前模块【加载地图数据】<br>关卡1，需要加载4个模块，当前模块【加载背景音乐】<br>关卡1，需要加载4个模块，当前模块【加载人物模型】<br>关卡1，需要加载4个模块，当前模块【加载新手教程】<br>下次关卡移除加载【新手教程】模块<br>第1次关卡准备完成<br>关卡2，需要加载3个模块，当前模块【加载人物模型】<br>关卡2，需要加载3个模块，当前模块【加载地图数据】<br>关卡2，需要加载3个模块，当前模块【加载背景音乐】<br>第2次关卡准备完成<br>关卡3，需要加载3个模块，当前模块【加载人物模型】<br>关卡3，需要加载3个模块，当前模块【加载地图数据】<br>关卡3，需要加载3个模块，当前模块【加载背景音乐】<br>第3次关卡准备完成</p>
</blockquote>
<blockquote>
<p>Phaser不在意具体有哪些线程arrive，只要达到它当前阶段的parties值，就触发屏障。是没有分辨具体是哪个线程的功能的，它在意的只是数量。</p>
</blockquote>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>内部使用了两个基于Fork-Join框架的原子类辅助。</p>
<h1 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>Fork/Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。</p>
<p>与其他ExecutorService相关的实现相同的是，Fork/Join框架会将任务分配给线程池中的线程。而与之不同的是，Fork/Join框架在执行任务时使用了<strong>工作窃取算法</strong>。</p>
<h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。</p>
<h2 id="Fork-Join的具体实现"><a href="#Fork-Join的具体实现" class="headerlink" title="Fork/Join的具体实现"></a>Fork/Join的具体实现</h2><p>Fork/Join框架简单来讲就是对任务的分割与子任务的合并，所以要实现这个框架，先得有<strong>任务</strong>。在Fork/Join框架里提供了抽象类<code>ForkJoinTask</code>来实现任务。</p>
<h3 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h3><p>ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量得多。</p>
<h4 id="fork-方法"><a href="#fork-方法" class="headerlink" title="fork()方法"></a>fork()方法</h4><p>使用线程池中的空闲线程异步提交任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本文所有代码都引自Java 8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// ForkJoinWorkerThread是执行ForkJoinTask的专有线程，由ForkJoinPool管理</span></span><br><span class="line">    <span class="comment">// 先判断当前线程是否是ForkJoin专有线程，如果是，则将任务push到当前线程所负责的队列里去</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         <span class="comment">// 如果不是则将线程加入队列</span></span><br><span class="line">        <span class="comment">// 没有显式创建ForkJoinPool的时候走这里，提交任务到默认的common线程池中</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>把任务推入当前工作线程的工作队列里</strong>。</p>
<h4 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h4><p>等待处理任务的线程处理完毕，获得返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">// doJoin()方法来获取当前任务的执行状态</span></span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        <span class="comment">// 任务异常，抛出异常</span></span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="comment">// 任务正常完成，获取返回值</span></span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * doJoin()方法用来返回当前任务的执行状态</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="comment">// 先判断任务是否执行完毕，执行完毕直接返回结果（执行状态）</span></span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    <span class="comment">// 如果没有执行完毕，先判断是否是ForkJoinWorkThread线程</span></span><br><span class="line">    ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        <span class="comment">// 如果是，先判断任务是否处于工作队列顶端（意味着下一个就执行它）</span></span><br><span class="line">        <span class="comment">// tryUnpush()方法判断任务是否处于当前工作队列顶端，是返回true</span></span><br><span class="line">        <span class="comment">// doExec()方法执行任务</span></span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        <span class="comment">// 如果是处于顶端并且任务执行完毕，返回结果</span></span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        <span class="comment">// 如果不在顶端或者在顶端却没未执行完毕，那就调用awitJoin()执行任务</span></span><br><span class="line">        <span class="comment">// awaitJoin()：使用自旋使任务执行完成，返回结果</span></span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">    <span class="comment">// 如果不是ForkJoinWorkThread线程，执行externalAwaitDone()返回任务结果</span></span><br><span class="line">    externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoinPool.join()会使线程免于阻塞。</p>
<p><img src="https://gitee.com/tzcqupt/blog-image/raw/master/img/forkJoin%E6%B5%81%E7%A8%8B%E5%9B%BE.PNG" alt=""></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>创建任务的时候我们一般不直接继承ForkJoinTask，而是继承它的子类<strong>RecursiveTask/RecursiveAction</strong></p>
<p><strong>RecursiveAction</strong>可以看做是无返回值的<strong>ForkJoinTask</strong></p>
<p><strong>RecursiveTask是有返回值的ForkJoinTask</strong>。</p>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p>ForkJoinPool是用于执行ForkJoinTask任务的执行（线程）池。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列 双端队列，ForkJoinTask存放在这里。</span></span><br><span class="line">    <span class="keyword">volatile</span> WorkQueue[] workQueues;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程的运行状态 ForkJoinPool的运行状态。SHUTDOWN状态用负数表示，其他用2的幂次表示。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> runState;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建ForkJoinWorkerThread的默认工厂，可以通过构造函数重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公用的线程池，其运行状态不受shutdown()和shutdownNow()的影响</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinPool common;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法，没有任何安全检查和参数校验，由makeCommonPool直接调用</span></span><br><span class="line">    <span class="comment">// 其他构造方法都是源自于此方法</span></span><br><span class="line">    <span class="comment">// parallelism: 并行度，</span></span><br><span class="line">    <span class="comment">// 默认调用java.lang.Runtime.availableProcessors() 方法返回可用处理器的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ForkJoinWorkerThreadFactory factory, // 工作线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                         UncaughtExceptionHandler handler, // 拒绝任务的handler</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> mode, // 同步模式</span></span></span><br><span class="line"><span class="function"><span class="params">                         String workerNamePrefix)</span> </span>&#123; <span class="comment">// 线程名prefix</span></span><br><span class="line">        <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">        <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">        <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">        <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">        <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">tzcqupt</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/tzcqupt/tzcqupt.github.io/2020/04/28/juc/juc-jdk-util/">https://github.com/tzcqupt/tzcqupt.github.io/2020/04/28/juc/juc-jdk-util/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/tzcqupt/tzcqupt.github.io">个人学习博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/28/JavaBook-Note/"><i class="fa fa-chevron-left">  </i><span>阿里开发手册阅读笔记</span></a></div><div class="next-post pull-right"><a href="/2020/04/28/juc/juc-note/"><span>深入浅出多线程学习笔记-基础篇</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2022 By tzcqupt</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">要想一天什么时候开始,而不是什么时候结束</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>